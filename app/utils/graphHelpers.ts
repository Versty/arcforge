import { Edge, ItemData } from '../types/graph';

// Edge type priority order (lower number = higher priority)
const EDGE_TYPE_PRIORITY: { [key: string]: number } = {
  'craft': 0,
  'repair': 1,
  'upgrade': 2,
  'recycle': 3,
  'salvage': 4,
  'trade': 5,
};

// Helper function to clean relation names
export const cleanRelationName = (relation: string): string => {
  return relation.replace(/_from$|_to$/g, '');
};

// Helper function to get edge type priority
export const getEdgePriority = (edge: Edge): number => {
  const cleanedRelation = cleanRelationName(edge.relation);
  return EDGE_TYPE_PRIORITY[cleanedRelation] ?? 999; // Unknown types go last
};

// Helper function to format edge label with level, quantity, and price
// Now accepts an optional translation function for relation names
export const formatEdgeLabel = (
  edge: Edge, 
  translateRelation?: (key: string) => string,
  translateItem?: (name: string) => string
): string => {
  let relation = cleanRelationName(edge.relation);
  
  // Rename trader/sold_by to trade for display
  if (relation === 'trader' || relation === 'sold_by') {
    relation = 'trade';
  }
  
  // Translate relation if translation function provided
  const translatedRelation = translateRelation 
    ? translateRelation(`graph.${relation}`) 
    : relation;
  
  const quantity = edge.quantity ? `${edge.quantity}x` : '';
  const levelInfo = edge.input_level || edge.output_level || '';
  
  // Extract price info from dependency for trader edges
  let priceInfo = '';
  if (edge.relation === 'trader' || edge.relation === 'sold_by') {
    const priceDep = edge.dependency?.find(d => d.type === 'price');
    if (priceDep) {
      const amount = priceDep.amount;
      const currency = priceDep.currency;
      priceInfo = `${amount} ${currency}`;
    }
  }
  
  // For recycle/salvage with level info, translate the source item name
  let levelDisplay = levelInfo;
  if (levelInfo && translateItem) {
    levelDisplay = translateItem(levelInfo);
  }
  
  // Build label
  const parts = [translatedRelation];
  if (quantity) parts.push(`(${quantity})`);
  if (priceInfo) parts.push(`[${priceInfo}]`);
  else if (levelDisplay) parts.push(`[${levelDisplay}]`);
  
  return parts.join(' ');
};

// Shape of elements we build for Cytoscape
interface GraphElementData {
  id?: string;
  label?: string;
  type?: 'center' | 'input' | 'output';
  nodeType?: string;
  rarity?: string;
  imageUrl?: string;
  itemName?: string;
  source?: string;
  target?: string;
  relation?: string;
  curvature?: number;
}

interface GraphElement {
  data?: GraphElementData;
}

// Build graph elements from item data
// Now accepts optional translation function for item names
export const buildGraphElements = (
  currentItem: ItemData,
  itemsLookup: Map<string, ItemData>,
  selectedEdgeTypes?: Set<string>,
  translateItem?: (name: string) => string,
  translateRelation?: (key: string) => string
) => {
  const elements: GraphElement[] = [];
  const CURVATURE = 90;
  
  // Helper to translate item name
  const tItem = (name: string) => translateItem ? translateItem(name) : name;
  
  // Helper to check if an edge should be included
  const shouldIncludeEdge = (relation: string): boolean => {
    if (!selectedEdgeTypes) {
      return true; // If no filter set provided, show all
    }
    
    if (selectedEdgeTypes.size === 0) {
      return false; // If explicitly no filters selected, show no edges (only center node)
    }
    
    // Check if the relation matches any selected type
    // Relations can be: craft_from, craft_to, recycle_from, etc.
    const cleanedRelation = cleanRelationName(relation);
    
    // Map both 'trader' and 'sold_by' to the 'trade' filter
    if (cleanedRelation === 'trader' || cleanedRelation === 'sold_by') {
      return selectedEdgeTypes.has('trade');
    }
    
    return selectedEdgeTypes.has(cleanedRelation);
  };
  
  // Center node - Selected item
  const centerId = `center-${currentItem.name}`;
  const centerImageUrl = currentItem.image_urls?.thumb 
    ? `/api/proxy-image?url=${encodeURIComponent(currentItem.image_urls.thumb)}`
    : '';
  elements.push({
    data: {
      id: centerId,
      label: tItem(currentItem.name),
      type: 'center',
      nodeType: currentItem.node_type || 'item',
      rarity: currentItem.infobox?.rarity,
      imageUrl: centerImageUrl,
    }
  });

  // Group edges by item name and direction, filtering by selected edge types
  const leftGrouped = new Map<string, Edge[]>();
  const rightGrouped = new Map<string, Edge[]>();
  
  currentItem.edges.forEach(edge => {
    // Skip edges that don't match the filter
    if (!shouldIncludeEdge(edge.relation)) {
      return;
    }
    
    if (edge.direction === 'in') {
      if (!leftGrouped.has(edge.name)) {
        leftGrouped.set(edge.name, []);
      }
      leftGrouped.get(edge.name)!.push(edge);
    } else {
      if (!rightGrouped.has(edge.name)) {
        rightGrouped.set(edge.name, []);
      }
      rightGrouped.get(edge.name)!.push(edge);
    }
  });

  // Sort edges within each group by priority
  leftGrouped.forEach((edges) => {
    edges.sort((a, b) => getEdgePriority(a) - getEdgePriority(b));
  });
  rightGrouped.forEach((edges) => {
    edges.sort((a, b) => getEdgePriority(a) - getEdgePriority(b));
  });
  
  // Sort groups by the priority of their primary (first) edge type
  const sortedLeftEntries = Array.from(leftGrouped.entries()).sort((a, b) => {
    return getEdgePriority(a[1][0]) - getEdgePriority(b[1][0]);
  });
  const sortedRightEntries = Array.from(rightGrouped.entries()).sort((a, b) => {
    return getEdgePriority(a[1][0]) - getEdgePriority(b[1][0]);
  });
  
  // Create left nodes (inputs)
  let leftIdx = 0;
  const totalLeftNodes = sortedLeftEntries.length;
  const leftIsEven = totalLeftNodes % 2 === 0;
  const leftMiddle = totalLeftNodes / 2;
  
  sortedLeftEntries.forEach(([itemName, edges]) => {
    const nodeId = `left-${itemName}`;
    const relatedItem = itemsLookup.get(itemName);
    const imageUrl = relatedItem?.image_urls?.thumb 
      ? `/api/proxy-image?url=${encodeURIComponent(relatedItem.image_urls.thumb)}`
      : '';
    
    elements.push({
      data: {
        id: nodeId,
        label: tItem(itemName),
        type: 'input',
        nodeType: relatedItem?.node_type || 'item',
        rarity: relatedItem?.infobox?.rarity,
        imageUrl: imageUrl,
        itemName: itemName, // Keep original name for navigation
      }
    });

    // Create edge from left to center with combined labels
    const edgeLabels = edges.map(e => formatEdgeLabel(e, translateRelation, translateItem)).join('\n');
    
    // Calculate curvature
    const curvature = leftIsEven 
      ? (leftIdx < leftMiddle ? -CURVATURE : CURVATURE)
      : (leftIdx < Math.floor(leftMiddle) ? -CURVATURE : leftIdx > Math.floor(leftMiddle) ? CURVATURE : 0);
    
    elements.push({
      data: {
        source: nodeId,
        target: centerId,
        label: edgeLabels,
        relation: edges.map(e => cleanRelationName(e.relation)).join(','),
        curvature: curvature,
      }
    });
    leftIdx++;
  });

  // Create right nodes (outputs)
  let rightIdx = 0;
  const totalRightNodes = sortedRightEntries.length;
  const rightIsEven = totalRightNodes % 2 === 0;
  const rightMiddle = totalRightNodes / 2;
  
  sortedRightEntries.forEach(([itemName, edges]) => {
    const nodeId = `right-${itemName}`;
    const relatedItem = itemsLookup.get(itemName);
    const imageUrl = relatedItem?.image_urls?.thumb 
      ? `/api/proxy-image?url=${encodeURIComponent(relatedItem.image_urls.thumb)}`
      : '';
    
    elements.push({
      data: {
        id: nodeId,
        label: tItem(itemName),
        type: 'output',
        nodeType: relatedItem?.node_type || 'item',
        rarity: relatedItem?.infobox?.rarity,
        imageUrl: imageUrl,
        itemName: itemName, // Keep original name for navigation
      }
    });

    // Create edge from center to right with combined labels
    const edgeLabels = edges.map(e => formatEdgeLabel(e, translateRelation, translateItem)).join('\n');
    
    // Calculate curvature
    const curvature = rightIsEven 
      ? (rightIdx < rightMiddle ? CURVATURE : -CURVATURE)
      : (rightIdx < Math.floor(rightMiddle) ? CURVATURE : rightIdx > Math.floor(rightMiddle) ? -CURVATURE : 0);
    
    elements.push({
      data: {
        source: centerId,
        target: nodeId,
        label: edgeLabels,
        relation: edges.map(e => cleanRelationName(e.relation)).join(','),
        curvature: curvature,
      }
    });
    rightIdx++;
  });

  return { elements, leftGrouped: new Map(sortedLeftEntries), rightGrouped: new Map(sortedRightEntries) };
};

// Build layout positions function
export const buildLayoutPositions = (
  elements: GraphElement[],
  leftGrouped: Map<string, Edge[]>,
  rightGrouped: Map<string, Edge[]>
) => {
  return (node: { id: () => string; data: (key: string) => string }) => {
    const nodeId = node.id();
    const nodeType = node.data('type');
    
    const leftX = 250;
    const centerX = 700;
    const rightX = 1150;
    const centerY = 400;
    const spacing = 180;
    
    // Center node
    if (nodeType === 'center') {
      return { x: centerX, y: centerY };
    }
    
    // Left nodes (inputs)
    if (nodeType === 'input') {
      const leftNodeIndex = elements
        .filter(el => el.data?.type === 'input')
        .findIndex(el => el.data?.id === nodeId);
      const totalLeftNodes = leftGrouped.size;
      const startY = centerY - ((totalLeftNodes - 1) * spacing) / 2;
      return { x: leftX, y: startY + leftNodeIndex * spacing };
    }
    
    // Right nodes (outputs)
    if (nodeType === 'output') {
      const rightNodeIndex = elements
        .filter(el => el.data?.type === 'output')
        .findIndex(el => el.data?.id === nodeId);
      const totalRightNodes = rightGrouped.size;
      const startY = centerY - ((totalRightNodes - 1) * spacing) / 2;
      return { x: rightX, y: startY + rightNodeIndex * spacing };
    }
    
    return { x: 0, y: 0 };
  };
};
